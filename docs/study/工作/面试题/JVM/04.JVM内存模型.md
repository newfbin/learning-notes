## 运行时数据区

执行完类加载过程之后，类会被加载到运行时数据区



## 程序计数器（线程私有）

程序计数器用于存储下一条要执行的JVM指令的地址。

程序计数器是线程私有的，每个线程都有自己的程序计数器

由于任何时间一个线程只有一个方法在执行，程序计数器会存储当前正在执行的方法的JVM指令地址，如果正在执行的是native方法，则未指定值。

## 虚拟机栈（线程私有）

虚拟机栈是线程私有的，栈的存储单位是栈帧，

每个栈帧都存储了**局部变量表**、**操作数栈**、**动态链接**、**方法返回地址**。

### 相关面试题

#### 举例栈溢出的情况

递归层数太多，导致StackOverFlow

可以通过-Xss设置虚拟机栈的大小

#### 分配的栈内存越大越好么？

不是，一定时间内降低了 OOM 概率，但是会挤占其它的线程空间，因为整个空间是有限的。

#### 垃圾回收是否涉及到虚拟机栈？

不会

## 本地方法栈（线程私有）

本地方法栈和虚拟机栈类似。

虚拟机栈用于管理Java方法的调用，本地方法栈用于管理本地方法的调用

本地方法栈也是线程私有的。

## 堆（线程共享）

堆是线程共享的

堆内存结构在 jdk1.8之前 和 jdk1.8及之后 不同

jdk1.8之前堆内存被分为新生代，老年代，永久代

jdk1.8及之后堆内存变成了 新生代、老年代、元空间。也就是永久代被替换为了元空间。

两者的区别在于jdk1.8之前的永久代是由JVM分配的，jdk1.8及之后的元空间直接使用本地内存。

通常会使用-Xms和-Xmx参数指定堆的最小内存和最大内存

### 新生代

新生代又可以划分为 Eden区、Survivor0 区和 Survivor1 区

在HotSpot虚拟机中Eden 区和另外两个 survivor 区默认占比是 8：1：1

### 对象分配过程

1. new 的对象先放伊甸园区
2. 当伊甸园的空间填满时，程序又需要创建对象，JVM 的垃圾回收器将对伊甸园区进行垃圾回收（MinorGC），将伊甸园区中的不再被其他对象所引用的对象进行销毁。再加载新的对象放到伊甸园区
3. 然后将伊甸园中的剩余幸存对象移动到幸存者 0 区。
4. 如果再次触发垃圾回收，此时上次幸存下来的放到幸存者 0 区的对象，如果没有回收，就会放到幸存者 1 区。
5. 如果再次经历垃圾回收，此时会重新放回幸存者 0 区，接着再去幸存者 1 区。
6. 默认经过15次垃圾回收之后，幸存的对象就会进入老年代
7. 当有对象要进入老年代，而老年代的内存不足时，会触发MajorGC
8. 如果在MajorGC之后仍无法进行对象的保存，就会产生OOM异常。

## 方法区（线程共享）

方法区与 Java 堆一样，是各个线程共享的内存区域。

方法区在逻辑上是属于堆的一部分，方法区还是被看作是一块独立于 Java 堆的内存空间。

JDK1.7之前，使用永久代实现方法区，主要存储类的信息，静态变量等

JDK1.8之后，改为使用元空间实现方法区，元空间使用本地内存提高性能和避免OOM错误，元空间大小可以调整，而永久代大小是固定的