## 为什么Redis这么快

- 使用C语言实现，效率高
- 数据存储在内存中，相比于传统的，访问速度快
- 使用单线程事件驱动模型结合IO多路复用，避免了线程间上下文切换产生不必要的开销
- Redis提供了一些高效的数据结构，如字符串、哈希、ZSet等，这些数据结构大多数操作的时间复杂度都为O(1)，并且经过优化之后，能够快速完成各种操作

## 为什么Redis要把数据放到内存中

- 放到内存中能够快速读写数据
- Redis提供了数据持久化机制，不用担心数据丢失

## 什么是Pipline

Pipline允许客户端在一次网络请求中发送多条命令到服务端

## Pipline和事务的区别

事务保证原子性

Pipline不保证原子性，如果一条命令执行失败，会继续执行其余的命令

## Pipline的好处

节省了网络传输时间

减少了服务端上下文切换的开销

## Redis持久化机制

Redis持久化机制主要有两种：RDB和AOF

### RDB

- RDB通过生成某一时刻的数据快照实现持久化，每隔一段时间生成一次
- 这种方式生成的文件是压缩的二进制文件，适合数据备份和恢复，但可能会在崩溃时，丢失最后一次备份之后的数据

**优点**：

- 生成的文件时压缩的二进制文件，能够快速加载数据
- RDB持久化在主线程之外进行，不会对主线程产生太大的影响

**缺点**:

- 容易丢失数据，会丢失最后一次备份之后的数据

### AOF

- 通过将命令追加到AOF文件末尾实现持久化
- 恢复的数据更加精确，文件体积大，重写会消耗更多的资源

**优点**：

- 比RDB方式恢复的数据更准确，因为每一次执行命令都会将命令存储到AOF文件中

**缺点**:

- 文件体积大
- 数据恢复的时间长

### 混合持久化

由于RDB和AOF各有优缺点，在Redis4.0的时候出现了混合持久化，通过 `aof-use-rdb-preamble`配置开启

混合持久化流程如下：

- 混合持久化在AOF重写时触发，在AOF重写时，会先生成当前时间的RDB快照，然后将其写入到新的AOF文件头部
- 这段时间会将主线程处理的命令存到重写缓冲区中，RDB写入完成后，将缓冲区中的命令拼接到新AOF文件尾部，最后用新的AOF文件替换旧的AOF文件
- 之后使用AOF文件进行恢数据复时，会先加载AOF文件头部的RDB快照，再执行AOF文件剩余的命令
- 大大提升了AOF文件恢复数据的速度

## RDB触发机制

### save命令

在主线程生成RDB文件，会阻塞主线程，期间不能执行读写命令

### bgsave命令（默认）

利用Fork操作得到一个子进程，在子进程中执行RDB生成，不会阻塞主线程

### 规则触发

通过配置save参数，决定多少秒内修改了多少条数据时进行持久化操作

## AOF写回策略

- always，每次执行命令都将命令同步到AOF文件，性能低，数据安全
- everysec，每秒执行一次 fsync , 性能有所提升，数据会丢失
- no，由操作系统决定何时同步数据，更快，最不安全

即使设置为always，也不保证完全不丢失数据。

因为AOF设置为always时，会先执行命令，再将命令写入AOF文件，有可能在还没写入到AOF文件的时候Redis宕机，导致数据丢失。这种丢失无法恢复

## AOF重写机制

根据当前键的最新值，生成对应的写命令。将新的命令写入到新的AOF文件，再替换掉旧的AOF文件

**触发条件**：

- 手动触发：BGREWRITEAOF命令手动触发AOF重写
- 自动触发：设置配置文件的参数
  - auto-aof-rewrite-min-size: AOF文件达到该大小后触发重写
  - auto-aof-rewrite-percentage:  AOF文件较上次增长该值后触发重写

## Redis事务

Redis事务中的命令会按照顺序执行，并且执行期间不会执行其他命令

Redis事务中的命令执行失败后，不会发生回滚，因为回滚会产生很多开销，这样设计能够减少开销，加快操作

## 如何用Redis实现分布式锁

使用SET NX命令 + Lua脚本实现分布式锁

因为Lua脚本是原子性的