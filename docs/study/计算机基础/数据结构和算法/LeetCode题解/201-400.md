## 283.移动零

**标签**：数组、双指针

**链接**：https://leetcode.cn/problems/move-zeroes

**题解**：该算法采用双指针法，目的是将数组中的零元素移动到数组末尾，同时保持非零元素的相对顺序。

- 定义两个指针`left`和`right`，都初始化为 0，`n`为数组的长度。`right`指针用于遍历整个数组，`left`指针用于记录可以放置非零元素的位置。
- 使用`while`循环，只要`right`指针没有越界（即`right < n`）就持续循环。
- 在每次循环中，检查`right`指针指向的元素是否不为 0。如果不为 0，说明这是一个非零元素，需要将其交换到`left`指针指向的位置，交换后`left`指针向右移动一位，准备下一个非零元素的放置。如果`right`指针指向的元素为 0，则直接将`right`指针向右移动一位，不进行交换操作，因为`left`指针位置保持不变，等待下一个非零元素来填充。
- 当`right`指针遍历完整个数组后，所有非零元素都已经按顺序移动到了数组的前面部分，而`left`指针之后的位置就可以全部填充为 0（在本算法中通过移动元素间接实现了这一效果）。

以输入数组`nums = [1, 0, 1, 0, 3, 12]`为例：

1. 初始状态：`left = 0`，`right = 0`。此时`nums[right] = 1`不为 0 ，调用`swap`方法（实际交换相同元素），`left`变为 1 ，`right`变为 1 。
2. 第一次循环：`nums[right] = 0`，`right`变为 2 。
3. 第二次循环：`nums[right] = 1`不为 0 ，交换`nums[left]`和`nums[right]`，数组变为`[1, 1, 0, 0, 3, 12]`，`left`变为 2 ，`right`变为 3 。
4. 第三次循环：`nums[right] = 0`，`right`变为 4 。
5. 第四次循环：`nums[right] = 3`不为 0 ，交换`nums[left]`和`nums[right]`，数组变为`[1, 1, 3, 0, 0, 12]`，`left`变为 3 ，`right`变为 5 。
6. 第五次循环：`nums[right] = 12`不为 0 ，交换`nums[left]`和`nums[right]`，数组变为`[1, 1, 3, 12, 0, 0]`，`left`变为 4 ，`right`变为 6 ，`right`超出数组长度，循环结束，零元素成功移动到数组末尾。

> 时间复杂度：O (n)，其中`n`是数组`nums`的长度。因为`right`指针遍历了整个数组一次，每次循环操作的时间复杂度都是常数级别的，所以总的时间复杂度为 O (n)。
>
> 空间复杂度：O (1)，算法只使用了常数级别的额外空间，如`n`、`left`、`right`以及`swap`方法中临时变量`temp`，没有随着输入规模增长而增加的额外空间，所以空间复杂度是 O (1)。





