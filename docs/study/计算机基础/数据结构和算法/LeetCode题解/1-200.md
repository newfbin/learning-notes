## 49.字母异位词分组

**标签**：数组、哈希表、字符串、排序

**链接**：https://leetcode.cn/problems/group-anagrams

**题解**：初始化一个空的 HashMap map。遍历字符串数组 strs。对第一个字符串 "eat"执行:

- 将 "eat" 转换为字符数组 ['e', 'a', 't']
- 对字符数组进行排序,得到 ['a', 'e', 't']
- 使用排序后的字符数组创建 key "aet"
- 从 map 中获取 key 为 "aet" 的值,由于不存在,因此创建一个新的空列表 list = []
- 将 "eat" 添加到 list 中,现在 list = ["eat"]
- 将 key 为 "aet",value 为 ["eat"] 的键值对存入 map

对第二个字符串 "tea" 执行类似操作:

- 字符数组为 ['t', 'e', 'a'],排序后为 ['a', 'e', 't'],key 为 "aet"
- 从 map 中获取 key 为 "aet" 的值,存在,为 ["eat"]
- 将 "tea" 添加到列表中,现在列表为 ["eat", "tea"]
- 将更新后的列表存入 map,key 为 "aet"

对其余字符串 "tan", "ate", "nat", "bat" 执行类似操作,最终 map 为:

- key 为 "aet",value 为 ["eat", "tea", "ate"]
- key 为 "ant",value 为 ["tan", "nat"]
- key 为 "abt",value 为 ["bat"]

从 map 中获取所有 value,构造结果列表,即 [ ["eat", "tea", "ate"], ["tan", "nat"], ["bat"] ]

可以看到,通过将每个字符串排序作为 key,并存储字母异位词的字符串列表作为 value,算法成功将字母异位词分组了。这样的分组过程更加高效,避免了对每个字符串都进行两两比较的低效操作。

> 时间复杂度：O(nklogk)，其中 n 是 strs 中的字符串的数量，k 是 strs 中的字符串的的最大长度。需要遍历 n 个字符串，对于每个字符串，需要 O(klogk) 的时间进行排序以及 O(1) 的时间更新哈希表，因此总时间复杂度是 O(nklogk)。
>
> 空间复杂度：*O*(*nk*)，其中 *n* 是 *strs* 中的字符串的数量，*k* 是 *strs* 中的字符串的的最大长度。需要用哈希表存储全部字符串。

## 128.最长连续序列

**标签**：并查集、数组、哈希表

**链接**：https://leetcode.cn/problems/longest-consecutive-sequence

**题解**：每个数都判断一次这个数是不是连续序列的开头那个数。

- 怎么判断呢，就是用哈希表查找这个数前面一个数是否存在，即num-1在序列中是否存在。存在那这个数肯定不是开头，直接跳过。
- 因此只需要对每个开头的数进行循环，直到这个序列不再连续，因此复杂度是O(n)。

以题解中的序列举例：**[100，4，200，1，3，4，2]**

去重后的哈希序列为：**[100，4，200，1，3，2]**

按照上面逻辑进行判断：

1. 元素100是开头，因为没有99，且以100开头的序列长度为1
2. 元素4不是开头，因为有3存在，过，
3. 元素200是开头，因为没有199，且以200开头的序列长度为1
4. 元素1是开头，因为没有0，且以1开头的序列长度为4，因为依次累加，2，3，4都存在。
5. 元素3不是开头，因为2存在，过，
6. 元素2不是开头，因为1存在，过。

> 时间复杂度：O(n)，其中对序列去重和遍历序列复杂度都为n，使用`HashSet#contains`方法判断num-1复杂度为1
>
> 空间复杂度：O(n)，需要创建一个HashSet保存去重后的序列，空间为n；需要一些变量存储最长序列长度、当前数字，空间为1