## 总结

本篇通过本地锁的问题引申出分布式锁的问题。然后介绍了五种分布式锁的方案，由浅入深讲解了不同方案的改进之处。

从上面几种方案的不断演进的过程中，知道了系统中哪些地方可能存在异常情况，以及该如何更好地进行处理。

举一反三，这种不断演进的思维模式也可以运用到其他技术中。

下面总结下上面五种方案的缺陷和改进之处。

**青铜方案**：

- 缺陷：业务代码出现异常或者服务器宕机，没有执行主动删除锁的逻辑，就造成了死锁。
- 改进：设置锁的自动过期时间，过一段时间后，自动删除锁，这样其他线程就能获取到锁了。

**白银方案**：

- 缺陷：占锁和设置锁过期时间是分步两步执行的，不是原子操作。
- 改进：占锁和设置锁过期时间保证原子操作。

**黄金方案**：

- 缺陷：主动删除锁时，因锁的值都是相同的，将其他客户端占用的锁删除了。
- 改进：每次占用的锁，随机设为较大的值，主动删除锁时，比较锁的值和自己设置的值是否相等。

**铂金方案**：

- 缺陷：获取锁、比较锁的值、删除锁，这三步是非原子性的。中途又可能锁自动过期了，又被其他客户端抢占了锁，导致删锁时把其他客户端占用的锁删了。
- 改进：使用 Lua 脚本进行获取锁、比较锁、删除锁的原子操作。

**钻石方案**：

- 缺陷：非专业的分布式锁方案。
- 改进：Redission 分布式锁。

**王者方案**：

见 [Redis-分布式锁-Redisson](./Redis-分布式锁-Redisson)



http://redis.cn/commands/set.html

https://www.bilibili.com/video/BV1np4y1C7Yf

