# 第11章 进阶 - 关系数据库的理论世界

------

## 1、关系模型 与 关系

### （1）诞生

**埃德加·弗兰克·科德**（英语：Edgar Frank Codd， 1923年8月23日－2003年4月18日），下简称 Codd，是`关系模型（Relational model）`和关系数据库的祖师爷。

> **数据库因采用了关系模型，才被称为关系数据库。**

Codd 写了两篇与关系模型相关的论文。第一篇是写于1969年的《大型数据库中关系存储的可推导性、冗余与一致性》。遗憾的是这篇论文发表在 IBM 公司内部期刊 IBM Research Report 上了，因此并没有引起外界的注意。
在接下来的 1970 年，Codd 又在权威学术杂志 **Communications of ACM** 上，以`《大型共享数据库的关系模型》`为题发表了**第二篇论文**。至此，**关系模型真正地问世了**。现在人们读到的论文基本上都是这一篇。但是，就像 C.J. Date 说的那样，**这篇论文充满了学术味道，而且比较偏重理论和数学，所以即使是数据库方面的专家，一般也不会去阅读。**

后来，Codd 凭借在关系型数据库方面的贡献获得了 **1981 年的图灵奖**。

### （2）什么是关系 and 关系模型

① 关系

`关系`：两个不同数据域上的值的集合通过一定的条件得到一个所有可能组合的子集。

比如，一个包含所有棒球队名字的集合，和一个包含所有城市的集合。将每个城市和球队的组合都列出来，这个列表可以很长很长。但我们只关注这个列表的一个子集：球队和其所属城市的组合。有效的组合包括 Chicago/White Sox、Chicago/Cubs 或者 Boston/Red Sox，但没有 Miami/Red Sox。

② 关系模型

1、维基百科解释：关系模型是基于**谓词逻辑**和**集合论**的一种数据模型，主要用于关系型数据库。

> 谓词逻辑（准确地说是“一阶谓词逻辑”）**和**集合论的知识在上文都介绍了。

2、教科书《数据库系统原理》解释：关系模型是用**关系**的形式表示实体和实体间联系的数据模型。

### （3）关系跟表的区别？

虽然关系和表看上去很像，但是还是有区别的：

1、关系中不允许存在**重复**的元组（tuple），而表中可以存在。

2、关系中的记录不存在**顺序**，而表存在。即：关系中的元组没有从上往下的顺序，而表中的行有从上往下的顺序；关系中的属性没有从左往右的顺序，而表中的列有从左往右的顺序。

3、关系可能需要满足**范式**，而表无所谓。（下面会介绍范式）

但是我们平常的日常语言，还是会混淆的称呼，下面是严格的对应关系：

| 关系（relation）  | 表（table）                          |
| ----------------- | ------------------------------------ |
| 元组（tuple）     | 行（row）或记录（record）            |
| 势（cardinality） | 行数（number of rows）               |
| 属性（attribute） | 列（column）或字段（field）          |
| 度（degree）      | 列数（number of columns）            |
| 定义域（domain）  | 列的取值集合（pool of legal values） |

### （4）关系的性质

关系不只是集合，它还有许多非常有趣的**性质**。

其中之一就是“`封闭性`”（closure property）。这个性质简单地说就是“**运算的输入和输出都是关系**”，换句话来说，就是“保证关系世界永远封闭”的性质。

## 2、范式（NF）

### （1）诞生

上面提到关系模型诞生历史，即 Codd 在 1970 年的第二篇论文里，首次出现了范式的概念，不过只有第一范式的想法（第二范式、第三范式的定义陆续出现在他之后的论文中）。

### （2）什么是范式？

`范式`是“符合某一种级别的关系模式的集合，表示一个关系内部各属性之间的联系的合理化程度”。通俗理解就是：**一张数据表的表结构所符合的某种设计标准的级别**。

目前关系数据库有六种范式：第一范式（1NF）、第二范式（2NF）、第三范式（3NF）、巴斯-科德范式（BCNF）、第四范式(4NF）和第五范式（5NF，又称完美范式）。

满足最低要求的范式是第一范式（1NF）。在第一范式的基础上进一步满足更多规范要求的称为第二范式（2NF），其余范式以次类推。**一般说来，数据库只需满足到第三范式 (3NF）就行了。**

### （3）前三个范式

1、`1NF`：列是最小的单元（原子性约束），不可再分。

如：

- 一个”省市区“字段，同时存了省市区（可能是用逗号分隔的字符串类型、或者是用了数组类型），应该拆分成"省"、"市"和“区”。
- 同一个收货地址信息，在一张表里，重复出现在两个及其以上的字段。

> 一般来说，在宿主语言中可以灵活选择数组、结构体、对象等多种数据类型来表现非规范化的数据。但是在插入到数据库中时，必须将它们分解成标量值，即按照第一范式进行规范化，然后再存入数据库。
>
> 但在关系数据库诞生三十年后，SQL-99 进行了扩展，使得我们可以定义不满足第一范式的“**数组类型**”。（还有后来的 JSON/JSONB 类型）这个扩展对关系模型来说究竟是好还是坏，还不能轻易下判断。
>
> 然而在宿主语言和数据库之间传递和接收数据时，应该有很多读者因为双方支持的数据结构不一致而苦恼过吧？特别是面向对象语言和关系数据库不一致的问题，这种问题称为“**阻抗不匹配**”。由此可见，希望数据库能支持在宿主语言中可用的数据结构这种需求也是有道理的。

2、`2NF`：满足1NF。表中要有主键（惟一性约束），且非主键列必须**完全依赖**于全部主键而非部分主键。

如：一个订单表【OrderDetail】（OrderID，ProductID，ProductName，ProductUnitPrice，Quantity），OrderID + ProductID 是主键，虽然 Quantity 是完全依赖于 OrderID + ProductID 主键的，但 ProductName、ProductUnitPrice 只**部分依赖**于 ProductID 主键，所以应该把 OrderDetail 表拆分为 Order 表 和 Product 表。

3、`3NF`：满足2NF。非主键列是**直接依赖**于主键，而不是直接依赖于非主键列。

如：还是上面的例子， 一个订单表【OrderDetail】（OrderID，ProductID，ProductName，ProductUnitPrice，Quantity），仅 OrderID 是主键，ProductID，ProductName，ProductUnitPrice，Quantity 都确实完全依赖 OrderID 主键，但其中，ProductName，ProductUnitPrice 是通过先依赖 ProductID，再通过 ProductID 依赖 OrderID 的方式来**传递依赖**的。所以还是应该把 OrderDetail 表拆分为 Order 表 和 Product 表。

### （4）后三个范式

1、`BCNF范式（博伊斯—科德范式）`：满足3NF。非主键列是**直接依赖**于**所有**主键（只有主键是多个才生效），而不是直接依赖于非主键列。

介绍略

2、第四范式

介绍略

3、第五范式

介绍略

### （5）更多范式

1、DK 范式（Domain-Key normal form）

介绍略

2、第六范式

介绍略

### （6）范式的利弊

因为范式的主要目的是为了**消除冗余**（范式级别越高，冗余越小），所以：

好处：

- 降低存储成本（数据库范式是在20世纪提出的，当时的磁盘存储成本还很高。）
- 提高拓展性

坏处：

- 降低性能。没有任何冗余的表设计会产生更多的查询行为。
- 增加设计表结构的难度

### （7）反范式设计

既然范式是为了消除冗余，那么`反范式`就是通过增加冗余、聚合的手段来**提升性能**。尤其对现在的互联网应用来说，性能比存储成本的要求更高。

> 参考最近又流行的 noSQL 数据库，就是大大的冗余。

建议：还是根据自身的业务特点在**范式和反范式中找到平衡点**。

