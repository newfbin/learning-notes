## * 介绍一下TCP/IP模型和OSI模型的区别

>  **OSI模型掌握程度**：
>
> - 理解 OSI 模型共有 7 层，能够说明是哪 7 层。
> - 能够粗浅描述每一层的基本功能和职责
> - 对于某些层，熟悉一些常见的协议，比如网络层的 IP，传输层的 TCP 和 UDP。
>
>  **TCP/IP模型掌握程度**：
>
> - 理解 TCP/IP 模型通常被描述为 4 层，能够清晰地描述网络模型的层次结构。
> - 能够解释每一层的作用，知道 TCP/IP 模型的层次是如何与 OSI 模型相对应的。
> - 能够举例说明每层使用的协议，对某些层次的深入理解，比如 TCP 的三次握手、四次挥手，IP 数据报的路由选择。
> - 理解不同层次间的交互：了解数据是如何在这些层次之间流动的，以及每一层如何为数据的传输添加或移除其所需的头部信息。

### OSI模型

OSI模型是国际标准化组织（ISO）制定的，它将计算机通信分为七层，每一层都负责特定的功能。
OSI包含七层，从下到上分别是是物理层、数据链路层、网络层、传输层、会话层、表示层、应用层。每一层都基于上一层构建，并且为下一层提供服务。OSI模型虽然理论完善，但是它的并未被广泛使用，更多被作为教学和理论分析的参考框架。与OSI模型相比，TCP/IP模型完全以实用为导向，几乎所有现代网络都基于TCP/IP模型。

### TCP/IP模型

TCP/IP模型包含四层，从下到上分别是网络接口层、网络层，传输层、应用层。

**网络接口层**对应OSI模型的物理层和数据链路层，传输单位为帧，该层的主要功能是和物理介质进行交互，确保数据能够在物理网络中传输。网络接口层以mac地址标识设备，这一层包含以太网协议，该协议会在IP数据报前加上mac头形成以太网帧，用于物理传输。以太网协议的MTU为1500字节，超过该大小的数据会分片传输。

**网络层**对应OSI模型的网络层，传输单位为数据包。网络层主要功能是对数据进行路由和转发，选择最佳路径将数据从源主机传输到目的主机。网络层的主要具体实现是IP协议，IP协议会为每一台主机分配一个IP地址，在IPv4中该地址的长度为32位，IPv6中该地址的长度位128位。IP协议可以通过子网掩码，将IP地址划分为网络号和主机号，提高地址的分配效率。

**传输层**对应OSI模型的传输层，传输层的传输单位有两种，一种是TCP报文段，另一种是UDP用户数据报。传输层负责端到端的数据传输，提供可靠的、无连接的数据传输服务。该层包含TCP协议和UDP协议。TCP协议提供的是可靠传输，通过超时重传、流量控制保证数据的可靠性和顺序性，适用于对数据可靠性要求较高的场景，如网页浏览，文件传输。UDP协议提供的是不可靠传输，只将数据发送出去，不考虑数据是否到达或者顺序是否正确。传输速度快，适用于音视频通话，网络直播的场景。UDP协议可以通过在应用层通过添加重传、校验等额外的机制使其变为可靠传输，但这样做也增加了UDP协议的复杂性。

**应用层**与OSI模型的会话层、表示层、应用层类似。该层提供直接与应用用户程序交互的接口,为网络上各种应用程序提供服务。主要协议有HTTP，FTP，SMTP等。

## * 从输入 URL 到页面展示到底发生了什么？

> **基本要求**：理解浏览器和服务器之间的交互过程，能够清晰地描述从输入URL到页面显示的整个流程。
>
> - DNS解析：描述如何将域名转换为IP地址。
> - TCP连接建立： 解释TCP三次握手的过程。
> - HTTP请求： 说明浏览器如何构建HTTP请求，并发送到服务器。
> - 服务器处理请求： 描述服务器接收请求、处理请求并生成响应的过程。
> - HTTP响应： 说明服务器如何将响应发送回浏览器。
> - TCP连接关闭： 描述TCP四次挥手的过程。
> - 浏览器渲染页面： 描述浏览器如何解析HTML、CSS和JavaScript，以及构建DOM树和渲染树。
> - 页面显示： 解释浏览器如何将渲染树绘制到屏幕上。
>
> **进阶要求**：对每个步骤的关键点有所了解，如DNS解析、TCP/IP连接、HTTP请求和响应、浏览器渲染等，引导面试官向具体的问题深入。
>
> **进阶要求**：对页面加载性能优化有所了解，如减少DNS查询时间、使用CDN、压缩资源、利用缓存等。

首先在输入URL后，浏览器会先检查浏览器缓存内是否有该URL的资源，如果有则直接展现出来，如果没有则会进行DNS域名解析，来获取URL的IP地址。

浏览器在进行DNS解析时，会依次查询浏览器缓存，本地Host文件，路由器缓存，DNS服务器，DNS根服务器。直到查找到URL的IP，DNS解析就算完成了。

DNS解析完成后，浏览器会通过TCP三次挥手和服务器建立连接，浏览器会构建请求头，请求行等信息。构建过程中会将Cookie等信息存到请求头中，构建完成后会向服务器发送HTTP请求，如果是HTTPS，还涉及到HTTPS的加解密流程。

服务器接收到浏览器发送的请求后，会生成响应数据并返回给浏览器。

浏览器接收到数据后和服务器进行TCP四次挥手断开连接，并开始解析数据，如果接收到的数据的请求头中含有301，302等状态码，则会重定向到新的地址；如果接收到的数据是字节流，浏览器会将请求提交给下载管理器；如果接收到的数据为HTML类型，浏览器则会构建DOM树，并将CSS样式和DOM树合并，构建出渲染树；最后布局和绘制渲染树，完成页面展示。

## * HTTP请求报文和响应报文是怎样的

> 掌握程度：
>
> - 基本结构： 能够描述HTTP请求报文和响应报文的基本结构和各部分的作用。
> - 关键字段： 对请求行、状态行、请求头和响应头中的常见字段有所了解。
>
> 后续延伸知识点：
>
> - HTTP方法： 能够区分并解释不同的HTTP方法及其用途。
> - HTTP 版本：熟悉 HTTP 不同版本的特性和之间的区别。
> - 状态码： 熟悉常见的HTTP状态码及其含义，特别是2xx、3xx、4xx和5xx系列。
> - 安全：了解HTTPS、SSL/TLS等安全协议及其在HTTP中的应用。
> - 优化：知道如何通过请求头和响应头进行性能优化，比如使用ETag、Last-Modified等字段进行 HTTP 缓存控制。

### 请求报文

请求报文包含请求行、请求头、空行、请求体。

**请求行**包含请求的方法、资源路径、HTTP版本。

**请求头**包含的字段比较多，常用的字段有Host、Accept、AcceptEncoding、ContentLength、ContentType、Authoration、Cookie、Connection、If-None-Match等。

**空行**位于请求头和请求体之间，用于分隔请求头和请求体。

**请求体**是请求的具体数据，在请求头中ContentType字段给出了请求体的类型。包括表单数据`application/x-www-form-urlencoded`、多部份数据`mutipart/form-data`、JSON数据`application/json`、XML数据`application/xml`、文本数据`text/plain`等。另外请求体也可以为空。

### 响应报文

响应报文包括状态行、响应头、空行、响应体

**状态行**包含HTTP版本、状态码、状态消息

**响应头**的常见字段有Content-Type、Content-Length、Server、Expires、Etag、Location、Set-Cookie、Access-Control-Allow-Origin等

**空行**位于响应头和响应体之间，用于分割响应头和响应体。

**响应体**是服务器返回的实际数据，包括文本、HTML页面、图片、视频等。

**请求行、状态行、请求头、响应头**都可以在浏览器控制台里打开某个具体的请求后，点击标头查看具体的信息。
查看**请求体**需要打开该请求的载荷，查看**响应体**需要打开该请求的响应查看。



## * HTTP请求方式有哪些

> 掌握程度：
>
> - 方法定义： 能够清晰地定义每个请求方法的基本用途，知道哪些方法可能会改变服务器状态，哪些不会，并能够根据场景选择合适的HTTP方法。
> - 安全性： 了解每种方法在安全性方面的考虑，特别是GET和POST方法的区别。
> - 幂等性： 理解幂等性的概念，并能识别哪些HTTP方法是幂等的（如GET、PUT、DELETE）。

**GET**：从服务器获取数据，而不对资源进行修改。

**POST**：向服务器发送以创建新资源。

**PUT**：向服务器发送数据以更新现有资源，如果资源不存在则创建新资源。

**DELETE**：删除服务器的资源。

**PATCH**：和GET类似，用来更新服务器的资源，但PATCH只会更改部分数据而不会更改整个资源。

**HEAD**：和GET类似，但服务器只返回响应头

**OPTIONS**：返回服务器支持的HTTP方法。

**TRACE**：会回显服务器收到的请求，主要用来诊断。

**CONNECT**：会与服务器建立一条隧道，通常用与建立HTTPS连接，客户端可以通过该隧道发送加密的数据。

## * GET请求和POST请求的区别

> 掌握程度：
>
> - 能够清晰地描述GET和POST请求的基本区别和各自的用途，能够根据场景选择合适的请求方法。
> - 知道GET请求数据附加在URL中，POST请求数据在请求体中。
> - 理解GET和POST请求在安全性和幂等性方面的差异。

首先GET请求用于从服务器获取资源，不会改变服务器的状态，POST用于提交数据到服务器，会改变服务器的状态。

GET请求的参数通过URL拼接传递，暴露在请求URL中，POST请求的参数存放在请求体中，相比之下POST请求安全一些。POST请求配合HTTPS加密传输可以进一步确保数据安全。

其次由于URL的长度有限制，GET请求的参数长度也有限制，不同浏览器和服务器对URL长度限制不同，一般为2048字节左右，因此不适合传输大量的数据。而POST请求的请求数据长度理论上没有限制，但是 Nginx 服务器会默认将请求体长度限制为1M，可以根据需求调整该大小。

另外GET请求会浏览器和CDN被缓存，当请求相同的URL时会直接返回缓存内容，所以GET请求适合请求不经常变动的资源，如静态页面，视频，图片。而POST请求默认不会被缓存，因为POST请求会对服务器产生影响，需要确保请求每一次都发送到服务器。

## *  HTTP请求中常见的状态码

> 掌握程度：
>
> - 状态码：能够根据1xx、2xx、3xx、4xx、5xx分类描述状态码，并对每个类别中的常见状态码能够解释其含义和使用场景。
> - 缓存：知道3xx状态码中的重定向是如何工作的。
> - 进阶：能够结合实际案例来讨论状态码的使用。

**1xx**：1xx类状态码属于提示信息，是协议处理的中间状态，实际用到的比较少

**2xx**：请求成功

- 200 - OK - 请求成功，服务器返回所请求的资源或数据
- 201 - Created - 请求成功并在服务器上创建新的资源，通常用于POST请求
- 204 - No Content - 请求成功，但服务器未返回任何内容。通常用于删除操作

**3xx**：请求重定向

- 301 - Moved Permently - 表示资源被永久移动到新的URL，客户端应该使用新的URL访问
- 302 - Found - 表示资源被临时移动到新的URL，用户应该原来的URL访问
- 304 - Not Modified - 表示该资源在服务器上并未修改，用户继续使用缓存版本

**4xx**：请求错误

- 400 - Bad Request - 表示请求无效或语法错误，服务器无法处理该请求。
- 401 - Unauthorized - 表示请求需要身份认证，客户端缺少有效凭证
- 403 - Forbidden - 表示服务器成功收到请求但拒绝执行，通常是权限问题
- 404 - Not Found - 表示请求的资源在服务器上未找到

**5xx**：表示服务器错误

- 500 - Internal Server Error - 表示服务器内部错误，无法完成请求
- 502 - Bad Gateway - 表示服务器作为网关或代理，从上游服务器收到无效相应
- 503 - Service Unavailable - 表示服务器暂时无法处理请求，通常是因为过载或维护

## * 什么是强缓存和协商缓存

> 掌握程度：
>
> - 基本概念：区分强缓存和协商缓存的概念，并解释它们的不同用途。
> - 工作流程: 能够描述浏览器和服务器在强缓存和协商缓存中如何交互。
> - HTTP头部字段: 知道实现强缓存和协商缓存的HTTP头部字段，如 Cache-Control, Last-Modified, ETag, If-Modified-Since, If-None-Match。
> - 性能优化: 理解缓存机制如何提高Web应用的性能和用户体验。

强缓存和协商缓存是HTTP缓存机制的两种类型，它们用于减少服务器负担，并提高网页的加载速度。

1. 强缓存会在客户端没有向服务器发送请求的情况下，直接从本地缓存获取资源。

   - Expires强缓存会设置一个强缓存时间，在此时间内都会直接读取本地缓存并返回。Expires强缓存判断缓存过期的机制是获取本地时间戳，与上一次响应头中的Expires字段的时间对比，判断是否继续使用本地缓存。这种方式有一个很大的缺点，就是本地时间可能会不准。因此这种方式目前已被废弃。

   - Cache-Control强缓存是目前使用的强缓存机制，它通过在HTTP响应头中的Cache-Control字段设置一个max-age实现，客户端会根据max-age明确缓存的存储时间，期间不会使用本地的时间戳，解决了Expires强缓存的缺点。

2. 在强缓存失效时，会使用协商缓存。浏览器会发送请求到服务器，通过If-Modified-Since、If-None-Match等请求头字段和服务器的Last-Modifiedd、Etag字段对比。如果资源未修改，服务器返回304 Not Modified状态码，告诉浏览器继续使用本地缓存；如果资源已修改，则返回新的资源，浏览器更新本地缓存。这种方式需要与服务器通信，但可以确保总是获取新的内容。

   - 基于Last-Modified的协商缓存：
     Last-Modified是资源最后的修改时间，服务器会在响应头中返回该字段。当客户端读取到Last-Nodified时，在下次请求中将该时间携带到请求头中的If-Modified-Since字段内。服务器比较请求中的If-Modified-Since的值与当前资源的Last-Modified值，如果两个值相等，则表示资源未发生变化，服务器会返回304 NotModified 状态码；如果两个值不相等，说明资源已发生变化，服务器会正常返回资源。
     基于Last-Modified的协商缓存有两个缺点：
     1.因为该方法是通过文件更新时间来判断的，在文件没有修改的情况下，文件更新时间依然会发生变化，比如修改文件内容后再修改回来。这样会导致文件内容没有修改，但缓存依然失效了。
     2.当文件在很短的时间内完成修改，比如几百毫秒，因为文件修改时间记录最小单位是秒，所以文件修改时间并不会改变，这样就算文件修改了，依然不会返回新的文件。
   - 基于ETag的协商缓存：
     该方式将原先比较文件修改时间的方式修改为了比较文件指纹，文件指纹是根据文件内容计算出的唯一Hash值。
     服务器会为每个文件生成一个文件指纹，在响应时，服务器会将该指纹存放在响应头的ETag字段内，和资源文件一起返回。
     客户端在每次请求时都会在请求头的If-Modified-Since字段写道上一次相应的ETag值。
     服务器比较If-Modified-Since的值和当前资源ETag的值，如果匹配，则资源未发生变化，返回状态码304 Not Modified；如果不匹配，说明资源发生了修改，服务器会重新计算出文件指纹，并将其和资源一起返回给客户端。

## * HTTP1.0和HTTP1.1的区别

> 掌握程度：
>
> - 特性：掌握 HTTP1.1 的特性，能够描述其优缺点。
> - 主要区别: 能够清晰地描述HTTP/1.0和HTTP/1.1的主要区别（持久连接和管道）
> - 持久连接: 知道HTTP/1.1支持持久连接。
> - 管道化: 理解HTTP/1.1的管道化技术。

1. **持久连接**：
2. **管道化**：
3. **缓存控制**：
4. **错误处理**：
5. **Host头**：
6. **带宽优化**：

## * HTTP2.0与HTTP1.1的区别？

> 掌握程度
>
> - 改进之处：了解 HTTP/1.1 协议存在的性能问题
> - 头部压缩: 了解 HTTP/2 的头部压缩机制，以及它如何减少数据传输量。
> - 二进制协议: 理解 HTTP/2 使用二进制协议对性能的改进。
> - 多路复用: 知道 HTTP/2 支持在单个连接上并行发送多个请求和响应，以及它如何减少连接开销。
> - 服务器推送: 知道服务器推送的概念，以及它如何帮助优化页面加载时间。
> - 协议细节: 对 HTTP/2 的协议细节有深入了解，如帧的类型和用途、流的状态管理等。
> - 理解 HTTP/2 队头阻塞问题的原因。



## * HTTP3.0有了解过吗？

> 掌握程度
>
> - QUIC 协议: 理解 HTTP/3 是基于 UDP 的 QUIC 协议 而不是 TCP。
> - 性能提升: 知道 HTTP/3 相对于 HTTP/2 在性能上的提升，特别是在连接建立和 队头阻塞 方面。
> - 加分项：
> - 技术细节: 对 QUIC 协议的技术细节有深入了解，如它的数据包结构、传输机制等。
> - 性能对比: 能够对比 HTTP/2 和 HTTP/3 在性能和使用场景上的差异。

